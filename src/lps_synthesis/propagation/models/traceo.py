import os
import typing

import tqdm
import numpy as np
import scipy.io as scipy

import lps_utils.quantities as lps_qty
import lps_utils.subprocess as lps_proc

import lps_synthesis.propagation.layers as lps_layer
import lps_synthesis.propagation.channel_response as lps_channel_rsp
import lps_synthesis.propagation.models.interfaces as model_core

class Traceo(model_core.PropagationModel):
    """
    TRACEO-based acoustic propagation model.
    """

    def __init__(self, workdir: str = "./channel/traceo"):
        self.workdir = workdir

    def compute_frequency_response(
        self,
        query: model_core.QueryConfig
    ) -> lps_channel_rsp.SpectralResponse:
        """
        Compute the frequency-domain channel response using TRACEO.
        """

        os.makedirs(self.workdir, exist_ok=True)

        frequencies, _,  = query.get_frequency_sweep()

        h_f_tau = None
        ranges = None
        depths = None

        for k, f in enumerate(tqdm.tqdm(frequencies, desc="Frequencies", ncols=120, leave=False)):

            in_name = "temp.in"
            in_file = os.path.join(self.workdir, in_name)
            out_file = os.path.join(self.workdir, "aad.mat")

            if os.path.exists(out_file):
                os.remove(out_file)

            self._export_file(
                frequency=f,
                query=query,
                filename=in_file
            )

            lps_proc.run_process(comand=f"traceo {in_name}",
                                running_directory=self.workdir)

            h_tau, z, r = self.read_file(self.workdir, f)

            if h_f_tau is None:
                n_depths, n_ranges = h_tau.shape
                h_f_tau = np.zeros((n_depths, n_ranges, len(frequencies)), dtype=np.complex128)
                ranges = r
                depths = z

            # if os.path.exists(in_file):
            #     os.remove(in_file)
            # if os.path.exists(out_file):
            #     os.remove(out_file)

            h_f_tau[:, :, k] = h_tau

        return lps_channel_rsp.SpectralResponse(
            h_f_tau = h_f_tau,
            depths = depths,
            ranges = ranges,
            frequencies = frequencies,
            sample_frequency = query.sample_frequency
        )

    @staticmethod
    def _export_file(
            frequency: lps_qty.Frequency,
            query: model_core.QueryConfig,
            filename: str):
        """
        Exports the Traceo input file (.in).

        Uses the Reciprocity Principle for efficiency:
        - Traceo Source is placed at the physical Sensor position.
        - Traceo Receivers are placed at the physical Source positions.
        """

        filename = filename if filename.endswith(".in") else filename + ".in"

        distance_sweep = query.get_distance_sweep()
        source_sweep = query.get_source_sweep()

        separation_line = \
            "--------------------------------------------------------------------------------\n"
        start_dist = 0
        max_dist = distance_sweep.get_end().get_m()

        air_interface = "0 0 0 0 0"
        air_depth = "0"
        bottom_interface = "0 0 0 0 0"
        bottom_depth = None

        def to_traceo_format(layer: lps_layer.AcousticalLayer) -> str:
            """ Layer in traceo description format. """
            return (
                f"{layer.get_compressional_speed().get_m_s():6f} "
                f"{layer.get_shear_speed().get_m_s():6f} "
                f"{layer.get_density().get_g_cm3():6f} "
                f"{layer.get_compressional_attenuation():6f} "
                f"{layer.get_shear_attenuation():6f} "
            )

        max_depth = 0
        n_layers = 0
        depths_strs = ""
        for depth, layer in query.description:
            max_depth = max(max_depth, depth.get_m())

            if isinstance(layer, lps_layer.Water):
                depths_strs += f"{depth.get_m():} {layer.get_compressional_speed().get_m_s()}\n"
                n_layers += 1

            elif isinstance(layer, lps_layer.Air):
                air_interface = to_traceo_format(layer)
                air_depth = str(depth.get_m())

            else:
                bottom_interface = to_traceo_format(layer)
                bottom_depth = str(depth.get_m())

        if bottom_depth is None:
            bottom_depth = f"{max_depth}"

        with open(filename, 'w', encoding="utf-8") as fid:

            # Title
            fid.write("Traceo File - Generated by LPS Acoustical Library\n")

            # Source Block
            fid.write(separation_line)
            fid.write("1" +"\n")
            fid.write(f"0.0 {query.sensor_depth.get_m()}" +"\n")
            fid.write(f"{start_dist - 1} {max_dist + 1}" +"\n")
            fid.write(f"{frequency.get_hz()}" +"\n")
            fid.write("501" +"\n")
            fid.write("-70.0 70.0" +"\n")

            # Altimetry Block
            fid.write(separation_line)
            fid.write("'V'" +"\n")
            fid.write("'H'" +"\n")
            fid.write("'FL'" +"\n")
            fid.write("'W'" +"\n")
            fid.write("2" +"\n")
            fid.write(f"{air_interface}" +"\n")
            fid.write(f"{start_dist - 2} {air_depth}" +"\n")
            fid.write(f"{max_dist + 2} {air_depth}" +"\n")

            # Sound Speed Block
            fid.write(separation_line)
            fid.write("'c(z,z)'" +"\n")
            fid.write("'TABL'" +"\n")
            fid.write(f"1 {n_layers}" +"\n")
            fid.write(depths_strs)

            # Objects Block
            fid.write(separation_line)
            fid.write("0" +"\n")

            # Bathymetry Block
            fid.write(separation_line)
            fid.write("'V'" +"\n")
            fid.write("'H'" +"\n")
            fid.write("'FL'" +"\n")
            fid.write("'W'" +"\n")
            fid.write("2" +"\n")
            fid.write(f"{bottom_interface}" +"\n")
            fid.write(f"{start_dist - 2} {bottom_depth}" +"\n")
            fid.write(f"{max_dist + 2} {bottom_depth}" +"\n")

            # Array Block
            fid.write(separation_line)
            fid.write("'RRY'" +"\n")
            fid.write(f"{len(distance_sweep)} {len(source_sweep)}" +"\n")
            ranges_str = " ".join(f"{d.get_m()}" for d in distance_sweep)
            fid.write(ranges_str + "\n")
            depths_str = " ".join(f"{z.get_m()}" for z in source_sweep)
            fid.write(depths_str + "\n")

            # Output Block
            fid.write(separation_line)
            fid.write("'ADR'" +"\n")
            fid.write("0.5" +"\n")

    @staticmethod
    def read_file(directory: str, freq: lps_qty.Frequency) -> typing.Tuple[np.array,
                                                                    typing.List[lps_qty.Distance],
                                                                    typing.List[lps_qty.Distance]]:
        """
        Reads the response from traceo(aad.mat) and composes H(d,r)

        Returns:
            H: complex matrix (Nd x Nr)
            depths: depth vector
            ranges: distance vector
        """

        filepath = os.path.join(directory, "aad.mat")
        data = scipy.loadmat(filepath)

        neigrays = int(np.squeeze(data["neigrays"]))
        ranges = np.atleast_1d(np.squeeze(data["rarray2d"]))
        depths = np.atleast_1d(np.squeeze(data["zarray2d"]))

        n_ranges = len(ranges)
        n_depths = len(depths)

        response = np.zeros((n_depths, n_ranges), dtype=np.complex128)
        w0 = 2 * np.pi * freq.get_hz()

        for k in range(1, neigrays + 1):
            fieldname = f"aad{k:05d}"

            aad = np.squeeze(data[fieldname])

            r_val = aad[0]
            d_val = aad[1]
            tau   = aad[2]

            amp = (aad[3] + 1j * aad[4]) * np.exp(1j * aad[5])

            d_idx = np.where(depths == d_val)[0]
            r_idx = np.where(ranges == r_val)[0]

            if r_idx.size > 0 and d_idx.size > 0:
                response[d_idx[0], r_idx[0]] += amp * np.exp(-1j * w0 * tau)

        depths = [lps_qty.Distance.m(d) for d in depths]
        ranges = [lps_qty.Distance.m(r) for r in ranges]

        return response, depths, ranges
