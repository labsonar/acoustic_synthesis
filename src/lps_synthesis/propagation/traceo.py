""" Module to acess the traceo for getting impulse response of a channel
"""
import typing
import os
import tqdm
import math
import numpy as np
import scipy.io as scipy

import lps_utils.quantities as lps_qty
import lps_utils.subprocess as lps_proc
import lps_synthesis.propagation.layers as lps_layer
import lps_synthesis.propagation.channel_description as lps_channel
import lps_synthesis.propagation.oases as oases



def read_file(directory: str, freq: lps_qty.Frequency) -> typing.Tuple[np.array,
                                                                  typing.List[lps_qty.Distance],
                                                                  typing.List[lps_qty.Distance]]:
    """
    Reads the response from traceo(aad.mat) and composes H(r,d)

    Returns:
        H: complex matrix (Nr x Nd)
        ranges: distance vector
        depths: depth vector
    """

    filepath = os.path.join(directory, "aad.mat")
    data = scipy.loadmat(filepath)

    neigrays = int(np.squeeze(data["neigrays"]))
    ranges = np.atleast_1d(np.squeeze(data["rarray2d"]))
    depths = np.atleast_1d(np.squeeze(data["zarray2d"]))

    n_ranges = len(ranges)
    n_depths = len(depths)

    response = np.zeros((n_ranges, n_depths), dtype=np.complex128)
    w0 = 2 * np.pi * freq.get_hz()

    for k in range(1, neigrays + 1):
        fieldname = f"aad{k:05d}"

        aad = np.squeeze(data[fieldname])

        r_val = aad[0]
        d_val = aad[1]
        tau   = aad[2]

        amp = (aad[3] + 1j * aad[4]) * np.exp(1j * aad[5])

        r_idx = np.where(ranges == r_val)[0]
        d_idx = np.where(depths == d_val)[0]

        if r_idx.size > 0 and d_idx.size > 0:
            response[r_idx[0], d_idx[0]] += amp * np.exp(-1j * w0 * tau)

    ranges = [lps_qty.Distance.m(r) for r in ranges]
    depths = [lps_qty.Distance.m(d) for d in depths]

    return response, ranges, depths

def export_file(
        frequency: lps_qty.Frequency,
        description: lps_channel.Description,
        source_depths: oases.Sweep,
        sensor_depth: lps_qty.Distance,
        distance: oases.Sweep,
        filename: str):
    """
    Exports the Traceo input file (.in).

    Uses the Reciprocity Principle for efficiency:
    - Traceo Source is placed at the physical Sensor position.
    - Traceo Receivers are placed at the physical Source positions.
    """

    filename = filename if filename.endswith(".in") else filename + ".in"

    separation_line = "--------------------------------------------------------------------------------\n"
    start_dist = 0
    max_dist = distance.get_end().get_m()

    air_interface = "0 0 0 0 0"
    air_depth = "0"
    bottom_interface = "0 0 0 0 0"
    bottom_depth = None

    max_depth = 0

    n_layers = 0
    depths_strs = ""
    for depth, layer in description:
        max_depth = max(max_depth, depth.get_m())

        if isinstance(layer, lps_layer.Water):
            depths_strs += f"{depth.get_m():} {layer.get_compressional_speed().get_m_s()}\n"
            n_layers += 1

        elif isinstance(layer, lps_layer.Air):
           air_interface = layer.to_traceo_format()
           air_depth = str(depth.get_m())

        else:
           bottom_interface = layer.to_traceo_format()
           bottom_depth = str(depth.get_m())

    if bottom_depth is None:
        bottom_depth = f"{max_depth}"

    with open(filename, 'w', encoding="utf-8") as fid:

        # Title
        fid.write("Traceo File - Generated by LPS Acoustical Library\n")

        # Source Block
        fid.write(separation_line)
        fid.write("1" +"\n")
        fid.write(f"0.0 {sensor_depth.get_m()}" +"\n")
        fid.write(f"{start_dist - 1} {max_dist + 1}" +"\n")
        fid.write(f"{frequency.get_hz()}" +"\n")
        fid.write("501" +"\n")
        fid.write("-70.0 70.0" +"\n")

        # Altimetry Block
        fid.write(separation_line)
        fid.write("'V'" +"\n")
        fid.write("'H'" +"\n")
        fid.write("'FL'" +"\n")
        fid.write("'W'" +"\n")
        fid.write("2" +"\n")
        fid.write(f"{air_interface}" +"\n")
        fid.write(f"{start_dist - 2} {air_depth}" +"\n")
        fid.write(f"{max_dist + 2} {air_depth}" +"\n")

        # Sound Speed Block
        fid.write(separation_line)
        fid.write("'c(z,z)'" +"\n")
        fid.write("'TABL'" +"\n")
        fid.write(f"1 {n_layers}" +"\n")
        fid.write(depths_strs)

        # Objects Block
        fid.write(separation_line)
        fid.write("0" +"\n")

        # Bathymetry Block
        fid.write(separation_line)
        fid.write("'V'" +"\n")
        fid.write("'H'" +"\n")
        fid.write("'FL'" +"\n")
        fid.write("'W'" +"\n")
        fid.write("2" +"\n")
        fid.write(f"{bottom_interface}" +"\n")
        fid.write(f"{start_dist - 2} {bottom_depth}" +"\n")
        fid.write(f"{max_dist + 2} {bottom_depth}" +"\n")

        # Array Block
        fid.write(separation_line)
        fid.write("'RRY'" +"\n")
        fid.write(f"{distance.get_n_steps()} {source_depths.get_n_steps()}" +"\n")
        ranges_str = " ".join(f"{d.get_m()}" for d in distance)
        fid.write(ranges_str + "\n")
        depths_str = " ".join(f"{z.get_m()}" for z in source_depths)
        fid.write(depths_str + "\n")

        # Output Block
        fid.write(separation_line)
        fid.write("'ADR'" +"\n")
        fid.write("0.5" +"\n")

def get_response(
        sample_frequency: lps_qty.Frequency,
        description: lps_channel.Description,
        source_depths: oases.Sweep,
        sensor_depth: lps_qty.Distance,
        distance: oases.Sweep,
        aux_dir: str):
    """
    Calculates the channel response H(r,d,f) using TRACEO for all frequencies of the FFT.

    Returns:
        H_f: complex ndarray (Nr, Nd, Nf)
        freqs: frequency vector (Hz)
        ranges, depths: spatial axes
    """

    os.makedirs(aux_dir, exist_ok=True)

    time_step = 1/sample_frequency
    n_samples = int(np.ceil(((1.5*distance.get_end())/description.get_base_speed())/time_step))
    n_samples = 2 ** math.ceil(math.log2(n_samples) - 1)

    df = sample_frequency / (2 * n_samples)
    freqs = np.arange(0, n_samples) * df

    h_f = None
    ranges = None
    depths = None

    for k, f in enumerate(tqdm.tqdm(freqs, desc="Frequencies", ncols=120, leave=False)):

        if k == 0:
            continue

        in_name = "traceo.in"
        in_file = os.path.join(aux_dir, in_name)
        out_file = os.path.join(aux_dir, "aad.mat")

        if os.path.exists(out_file):
            os.remove(out_file)

        export_file(
            frequency=f,
            description=description,
            source_depths=source_depths,
            sensor_depth=sensor_depth,
            distance=distance,
            filename=in_file
        )

        lps_proc.run_process(comand=f"traceo {in_name}",
                             running_directory=aux_dir)

        h_rd, r, z = read_file(aux_dir, f)

        if h_f is None:
            n_ranges, n_depths = h_rd.shape
            h_f = np.zeros((n_ranges, n_depths, n_samples), dtype=np.complex128)
            ranges = r
            depths = z

        h_f[:, :, k] = h_rd

    return h_f, ranges, depths, freqs








# def estimate_transfer_function(description: lps_channel.Description,
#                     source_depth: typing.List[lps_qty.Distance],
#                     sensor_depth: lps_qty.Distance,
#                     max_distance: lps_qty.Distance = lps_qty.Distance.km(1),
#                     max_distance_points: int = 128,
#                     sample_frequency: lps_qty.Frequency = lps_qty.Frequency.khz(16),
#                     frequency_range: typing.Tuple[lps_qty.Frequency] = None,
#                     filename: str = "test"):
#     """ Function to estimate a transfer function """
#     original_directory = os.getcwd()

#     file_directory = os.path.dirname(filename)
#     file_without_extension = os.path.splitext(os.path.basename(filename))[0]

